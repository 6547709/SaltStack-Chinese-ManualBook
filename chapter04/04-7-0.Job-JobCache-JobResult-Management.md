# JOB MANAGEMENT
*New in version 0.9.7.*

由于Salt可以执行在许多系统上运行的作业，因此Salt需要能够管理这些在许多系统上运行的作业。

## THE MINION PROC SYSTEM
Salt Minions在Salt cachedir中维护一个proc目录。 proc目录下维护的是以执行的作业ID命名的文件。 这些文件包含有关minion上当前正在运行的作业的信息，并允许查找作业。 它位于cachedir下的proc目录中，默认配置位于/var/cache/salt/{master|minion}/proc下。

## FUNCTIONS IN THE SALTUTIL MODULE
Salt 0.9.7 版本中为saltutil 模块引入了一些新的jobs管理函数，它们是:
- `running` Returns the data of all running jobs that are found in the proc directory.
- `find_job` 基于指定的job id返回作业运行数据。
- `signal_job` 允许向一个给定 jid 的作业发送一个signal信号。
- `term_job` 向处理特定job任伤的进程发送一个终止任务的信号 (SIGTERM, 15) 。
- `kill_job` 向处理特定job任伤的进程发送一个强行终止任务的信号(SIGKILL, 9) 。

这些功能函数共同组成了管理minion级别jobs的后端功能核心。

## THE JOBS RUNNER
为了提高jobs管理的便利性，开发了一个runner前端和报告子系统。 jobs runner使唤得查看数据更简单、更清晰。

jobs runner 包含了多个功能函数：

### ACTIVE
active函数将对所有minions执行saltutil.running，并使用更加可用和紧凑的格式格式化有关所有正在运行的作业的返回数据。 active函数还将比较已返回的作业和仍在运行的作业，从而更容易查看哪些系统已完成作业以及哪些系统仍在等待。

```bash
# salt-run jobs.active
```

### LOOKUP_JID
执行作业时，返回数据将发送回master服务器并进行缓存。 默认情况下，它会缓存24小时，缓存时长可以通过master配置中的keep_jobs选项进行配置。 所以在缓存有效时间内，使用`lookup_jid` runner可以查看到salt命令初始作业调用所返回数据相同数据。
```bash
# salt-run jobs.lookup_jid <job id number>
```

### LIST_JOBS
在查找一个已经执行过的job之前，可能需要先找到其job ID。 `list_jobs`可以通过解析缓存的执行数据，显示已经或部分返回的作业的所有作业数据。
```bash
# salt-run jobs.list_jobs
```

# SCHEDULING JOBS

Salt的调度系统允许对minions或master进行增量执行。 调度系统对外暴露了执行任务的能力，被执行的对象可以是运行在master上的runner，也可以是在minions上运行的execution功能函数。

可以通过多种方法启用作业调度的功能：
- `schedule`参数，在master 或 minion 配置文件中进行设置。这需要重启master或minion服务使配置生效。
- Minion pillar data，调度功能是通过刷新minion的pillar数据来实现的，例如使用`saltutil.refresh_pillar`。
- [schedule state](https://docs.saltstack.com/en/latest/ref/states/all/salt.states.schedule.html#module-salt.states.schedule) 或 [schedule module](https://docs.saltstack.com/en/latest/ref/modules/all/salt.modules.schedule.html#module-salt.modules.schedule)

> 注意：调度程序在master和minions上分别执行不同的功能。 当在master上运行时，功能函数是引用runner程序，当在minion上运行时，功能函数则被指定为execution函数。

除非将配置设置为信息级别或更高级别，否则通过调度安排运行的作业在minion上不会输出信息。 请参阅`minion-logging-settings`。

正如所有states一样，states在minion上被执行，你可以为其传递位置参数并提供指定名称参数的YAML字典。
```yaml
schedule:
  job1:
    function: state.sls
    seconds: 3600
    args:
      - httpd
    kwargs:
      test: True
```
该调度作业将执行这样的命令: `state.sls httpd test=True` ，间隔3600秒执行一次。
```yaml
schedule:
  job1:
    function: state.sls
    seconds: 3600
    args:
      - httpd
    kwargs:
      test: True
    splay: 15
```
该调度作业将执行这样的命令: `state.sls httpd test=True` ，间隔3600秒执行一次，两次任务之间执行一个0~15秒的延时。
```yaml
schedule:
  job1:
    function: state.sls
    seconds: 3600
    args:
      - httpd
    kwargs:
      test: True
    splay:
      start: 10
      end: 15
```
该调度作业将执行这样的命令: `state.sls httpd test=True` ，间隔3600秒执行一次，两次任务之间执行一个10~15秒的延时。

## SCHEDULE BY DATE AND TIME
*New in version 2014.7.0.*

也可以使用Python dateutil库支持的日期字符串指定作业的执行频率。 这需要安装Python dateutil库。
```yaml
schedule:
  job1:
    function: state.sls
    args:
      - httpd
    kwargs:
      test: True
    when: 5:00pm
```
该调度作业将执行这样的命令: `state.sls httpd test=True` ，在minion上的本地时间5:00PM时执行。
```yaml
schedule:
  job1:
    function: state.sls
    args:
      - httpd
    kwargs:
      test: True
    when:
      - Monday 5:00pm
      - Tuesday 3:00pm
      - Wednesday 5:00pm
      - Thursday 3:00pm
      - Friday 5:00pm
```
该调度作业将执行这样的命令: `state.sls httpd test=True` ，在minion上的本地时间周一、周三、周五的5:00PM执行，在周二、周四的3:00PM执行。
```yaml
schedule:
  job1:
    function: state.sls
    args:
      - httpd
    kwargs:
      test: True
    when:
      - 'tea time'
whens:
  tea time: 1:40pm
  deployment time: Friday 5:00pm
```
Salt调度程序还允许将自定义的惯用语用于when参数。 这些whens可以存储为pillar值或grain值。
```yaml
schedule:
  job1:
    function: state.sls
    seconds: 3600
    args:
      - httpd
    kwargs:
      test: True
    range:
      start: 8:00am
      end: 5:00pm
```
该调度作业将执行这样的命令: `state.sls httpd test=True` ，间隔3600秒执行一次， 在minion本地时间的8:00 AM 到 5:00 PM之间执行。表示时间范围的参数必须是使用 `dateutil` 格式表示的字符串。
```yaml
schedule:
  job1:
    function: state.sls
    seconds: 3600
    args:
      - httpd
    kwargs:
      test: True
    range:
      invert: True
      start: 8:00am
      end: 5:00pm
```
该调度作业将执行这样的命令: `state.sls httpd test=True` ，间隔3600秒执行一次， 在minion本地时间的8:00 AM 到 5:00 PM之外的时间段中执行该作业。表示时间范围的参数必须是使用 `dateutil` 格式表示的字符串。
```yaml
schedule:
  job1:
    function: pkg.install
    kwargs:
      pkgs: [{'bar': '>1.2.3'}]
      refresh: true
    once: '2016-01-07T14:30:00'
```
这将会调度函数pkg.install在指定时间执行一次。 作业完成后，不会删除计划条目job1，因此在作业执行完成后请使用`schedule.delete`手动删除它。

默认日期格式为ISO 8601，但也可以通过指定once_fmt选项来覆盖，如下所示：
```yaml
schedule:
  job1:
    function: test.ping
    once: 2015-04-22T20:21:00
    once_fmt: '%Y-%m-%dT%H:%M:%S'
```

## MAXIMUM PARALLEL JOBS RUNNING
*New in version 2014.7.0.*

调度程序还支持确保运行特定例程时的N个副本不超过N个。 建议将此配置用于那些可能长时间运行的作业，以确保在遇到基础设施服务中断事件时，这些作业不会产生错误的副本。

The default for `maxrunning` is 1.
```yaml
schedule:
  long_running_job:
    function: big_file_transfer
    jid_include: True
    maxrunning: 1
```

## CRON-LIKE SCHEDULE
*New in version 2014.7.0.*

```yaml
schedule:
  job1:
    function: state.sls
    cron: '*/15 * * * *'
    args:
      - httpd
    kwargs:
      test: True
```
调度程序还支持使用类似cron的格式调度作业。 这需要依赖于Python `croniter库。`

## JOB DATA RETURN
*New in version 2015.5.0.*

默认情况下，从Salt调度程序运行的作业的数据将返回到master。 将`return_job`参数设置为False将阻止将数据发送回Salt master。
```yaml
schedule:
  job1:
    function: scheduled_job_function
    return_job: False
```

## JOB METADATA
*New in version 2015.5.0.*

一些使用场景下，使用特定数据来区分一个作业与其他的作业时会很方便。 通过元数据参数，可以为调度作业关联特定的值。 这些值不用于作业的执行，但如果与`return_job`参数结合使用时，就可以在稍后用于搜索特定的作业。 必须将元数据参数指定为字典形式，否则将忽略它。
```yaml
schedule:
  job1:
    function: scheduled_job_function
    metadata:
      foo: bar
```

## RUN ON START
*New in version 2015.5.0.*

默认情况下，根据minion的启动时间安排的任何作业将在minion启动时运行预定作业。 有时这不是理想的情况。 使用设置为`False`的`run_on_start`参数将导致调度程序跳过此第一次运行并等待下一次计划运行：
```yaml
schedule:
  job1:
    function: state.sls
    seconds: 3600
    run_on_start: False
    args:
      - httpd
    kwargs:
      test: True
```

## UNTIL AND AFTER
*New in version 2015.8.0.*
```yaml
schedule:
  job1:
    function: state.sls
    seconds: 15
    until: '12/31/2015 11:59pm'
    args:
      - httpd
    kwargs:
      test: True
```

使用until参数，Salt调度程序允许你指定调度 作业的结束时间。 如果指定了此参数，则在指定的时间过后，作业将不会运行。 时间应使用`dateutil`库支持的格式指定。 这需要安装Python `dateutil`库。

```yaml
schedule:
  job1:
    function: state.sls
    seconds: 15
    after: '12/31/2015 11:59pm'
    args:
      - httpd
    kwargs:
      test: True
```
使用after参数，Salt调度程序允许你指定调度作业的开始时间。 如果指定了此参数，则在指定的时间过去之前，作业将不会运行。 时间应以`dateutil`库支持的格式指定。 这需要安装Python `dateutil`库。

## SCHEDULING STATES
```yaml
schedule:
  log-loadavg:
    function: cmd.run
    seconds: 3660
    args:
      - 'logger -t salt < /proc/loadavg'
    kwargs:
      stateful: False
      shell: /bin/sh
```

## SCHEDULING HIGHSTATES
要设置一个每隔60分钟在minion上运行一个highstate，在minion配置或pillar中设置它：
```yaml
schedule:
  highstate:
    function: state.highstate
    minutes: 60
```
时间间隔的单位可以使用 seconds, minutes, hours, 或 days 。

## SCHEDULING RUNNERS
支持在master配置文件指定允许使用哪些Runner executions:
```yaml
schedule:
  run_my_orch:
    function: state.orchestrate
    hours: 6
    splay: 600
    args:
      - orchestration.my_orch
```
上述配置类似于每6小时运行`salt-run state.orch orchestration.my_orch`。


## SCHEDULER WITH RETURNER
调度程序对于收集有关minion的监视数据等任务时也很有用，此调度选项将收集状态数据并将其发送到MySQL runner：
```yaml
schedule:
  uptime:
    function: status.uptime
    seconds: 60
    returner: mysql
  meminfo:
    function: status.meminfo
    minutes: 5
    returner: mysql
```
由于反复指定runner可能很烦人，因此schedule_returner选项可用于指定一个或一个全局returners列表在调度时被使用。
