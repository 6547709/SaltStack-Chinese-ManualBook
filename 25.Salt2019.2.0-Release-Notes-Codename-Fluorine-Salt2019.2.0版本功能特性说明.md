Salt2019.2.0 Release Notes Codename Fluorine - Salt2019.2.0 的新版本功能特性说明
>官网英语原文参见：https://docs.saltstack.com/en/latest/topics/releases/2019.2.0.html

# PYTHON 2.7 DEPRECATION
Python 2.7在2020年1月1日将达到其生命周期终止时间（EOL），SaltStack将在Sodium发行版本或之后的版本中弃用对Python 2的支持。该决定有待进一步的社区讨论确定。
>Codename是SaltStack为了便于记忆和使用，而为Salt发行版本命名的一种代码名称。SaltStack采用了元素周期表中各元素的名称和顺序，每个元素均代指某一个的Salt发行版本，依次使用。
>
>例如:
- Salt 2016.10.0 —— Carbon(碳)
- Salt 2017.7.0 —— Nitrogen(氮)
- Salt 2018.3.0 —— Oxygen(氧)
- Salt 2019.2.0 —— Fluorine(氟)
- ? —— Neon(氖)
- ? —— Sodium(钠)

# YAML RENDERER的在非后向兼容方面的变化
在早期版本中，假设数据是包含unicode类型的键/值的列表或字典，这被认为是Python 2中的有效用法：
```jinja
/etc/foo.conf:
  file.managed:
    - source: salt://foo.conf.jinja
    - template: jinja
    - context:
        data: {{ data }}
```
一个常见的用例是使用一个Salt的自定义[Jinja过滤器](https://docs.saltstack.com/en/latest/topics/jinja/index.html#std:jinja_ref-custom-jinja-filters)返回列表或词典，例如[ipv4过滤器](https://docs.saltstack.com/en/latest/topics/jinja/index.html#std:jinja_ref-ipv4)。

在Python 2中，Jinja将使用“u”前缀（例如{u'foo'：u'bar'}）以在列表/字典中显示unicode字符串类型。 虽然属于无效的YAML，但早期版本会成功加载这些值。

截至本版本，上述SLS将会导致错误消息。 如果仍然需要允许将数据结构直接转储到SLS文件中，请使用[tojson Jinja](#http://jinja.pocoo.org/docs/2.10/templates/#tojson)过滤器：
```jinja
/etc/foo.conf:
  file.managed:
    - source: salt://foo.conf.jinja
    - template: jinja
    - context:
        data: {{ data|tojson }}
```
>Note：
>此过滤器是添加到了Jinja 2.9中。 但是，也不必担心！ 在Salt 2018.3.3版本也添加了一个类似功能的tojson过滤器，如果此过滤器尚不存在，将使用该过滤器，以实现功能兼容，使其在RHEL 7和Ubuntu 14.04等平台上可用，这些平台上提供是旧版本的Jinja。

>Important：
>json_encode_dict和json_encode_list过滤器实际上并没有将结果转储到JSON。 而且由于tojson完成了那些过滤器的设计目的，它们现在已被弃用，并将在Neon版本中被移除。 在所有使用json_encode_dict和json_encode_list的场景下都应该替换为使用tojson过滤器。

# ANSIBLE PLAYBOOK STATE AND EXECUTION MODULES
除了包含Oxygen版本中的ansible模块外，2019.2.0版本中还增加了运行playbooks的功能。 这包括一个ansible playbooks状态模块，它可以在目标主机上用来运行ansible playbooks，或者用在编排state runner中。
```yaml_utf8
install nginx:
  ansible.playbooks:
    - name: install.yml
    - git_repo: git://github.com/gtmanfred/playbook.git
    - git_kwargs:
        rev: master
```
playbooks模块还支持指定一个git repo地址，用来获取部分运行所需的资源文件，或者在运行playbook时可以指定使用一个特定的目录。

# NETWORK AUTOMATION - 网络自动化
从此版本开始，Salt为各种网络操作系统提供了更广泛的支持，以及配置变更或命令执行的功能。

## NETBOX
在上一版本2018.3.0中新添加的[netbox执行模块](#https://docs.saltstack.com/en/latest/ref/modules/all/salt.modules.netbox.html#module-salt.modules.netbox)的功能，在该版本中扩展出了更多的可用功能列表：
- netbox.create_circuit
- netbox.create_circuit_provider
- netbox.create_circuit_termination
- netbox.create_circuit_type
- netbox.create_device
- netbox.create_device_role
- netbox.create_device_type
- netbox.create_interface
- netbox.create_interface_connection
- netbox.create_inventory_item
- netbox.create_ipaddress
- netbox.create_manufacturer
- netbox.create_platform
- netbox.create_site
- netbox.delete_interface
- netbox.delete_inventory_item
- netbox.delete_ipaddress
- netbox.get_circuit_provider
- netbox.get_interfaces
- netbox.get_ipaddresses
- netbox.make_interface_child
- netbox.make_interface_lag
- netbox.openconfig_interfaces
- netbox.openconfig_lacp
- netbox.update_device
- netbox.update_interface

除了这个执行模块，Salt用户还可以通过[netbox External Pillar模块](#https://docs.saltstack.com/en/latest/ref/pillar/all/salt.pillar.netbox.html#module-salt.pillar.netbox)直接从NetBox将数据加载到设备Pillar中。
>netbox是网络设施信息化与可视化管理项目，有兴趣的同学可以移动这里：https://github.com/digitalocean/netbox/tree/master

## NETMIKO
NETMIKO=Network + Paramiko

[Netmiko](#https://github.com/ktbyers/netmiko)是一个简化Paramiko SSH与网络设备连接的多供应商库，现已正式集成到Salt中。 现在可以通过netmiko代理模块或直接从任何Salt Minions使用它，传递连接凭据 - 请参阅[netmiko执行模块](#https://docs.saltstack.com/en/latest/ref/modules/all/salt.modules.netmiko_mod.html#module-salt.modules.netmiko_mod)的文档。

## ARISTA
Arista交换机现在可以在pyeapi代理模块下进行管理，并通过pyeapi执行模块执行RPC请求。

## CISCO NEXUS
虽然在版本代号Carbon（2016.11）中已经添加了对基于SSH的操作的支持，但新的nxos_api代理模块和nxos_api允许通过NX-API管理Cisco Nexus交换机。

重要的是要注意这些模块没有第三方依赖，因此它们可以直接使用任何Salt Minion。 这也意味着用户可以直接在Nexus交换机上安装常规Salt Minion，并像常规服务器一样的管理这些网络设备。

## GENERAL-PURPOSE MODULES
新的ciscoconfparse执行模块可用于具有Cisco IOS样式配置（一个空格缩进）的各种网络平台的基本配置解析、审计或验证，以及大括号分隔的配置样式。

iosconfig可用于Cisco IOS样式配置的各种配置操作，例如： configuration cleanup, tree representation of the config等。

## NAPALM
### COMMIT AT AND COMMIT CONFIRMED
从此版本开始，NAPALM用户可以执行计划提交（通常称为“commit at”）和“commit confirmed”（除非用户通过运行另一个命令确认，否则将恢复配置更改）。 这些功能可通过net.load_config和net.load_template执行函数或netconfig.managed的commit_in，commit_at，revert_in或revert_at参数获得。

对应的执行函数net.confirm_commit或net.cancel_commit，以及State函数netconfig.commit_cancelled或netconfig.commit_confirmed可用于确认或取消提交。

请注意，无论网络设备本机是否支持，任何平台都可以使用提交确认和提交已取消的功能。 但是，要小心谨慎，并确保在生产中使用它们之前阅读并理解警告。

>NAPALM（具有多供应商支持的网络自动化和可编程性抽象层）是一个Python库，它实现了一组使用统一API与不同网络设备操作系统交互的功能。NAPALM支持多种方法来连接设备，操作配置或检索数据，对Cisco和Juniper等设备的支持较好。

### MULTIPLE TEMPLATES RENDERED SIMULTANEOUSLY
net.load_template执行函数和netconfig.managed State函数的template_name参数现在支持使用模板列表了。 当一个非常大的Jinja模板被拆分成多个更小且更易于阅读的模板时，这一点尤其有用，这些模板最终可以在其他国家或地区得到重复使用。 例如，使用两个不同的模板并通过一次提交更改设备配置，以下语法不能同时管理NTP和BGP的配置：
```YAML
manage_bgp_and_ntp:
  netconfig.managed:
    - template_name:
        - salt://templates/bgp.jinja
        - salt://templates/ntp.jinja
    - context:
        bpg: {{ pillar.bgp }}
        ntp: {{ pillar.ntp }}
```

### CONNECTION RE-ESTABLISHMENT ON DEMAND
从此版本开始，在NAPALM Proxy Minion下运行时执行的任何NAPALM命令都支持force_reconnect魔术参数。

Proxy Minions通常在Minion启动时与远程网络设备建立连接，并且该连接将永久使用。

如果需要在设备上执行命令但是使用不同的参数进行连接（由于各种原因，例如，无法验证Pillar中指定的用户作为身份验证系统 - 比方说TACACS +不可用，或DNS解析器是目前已关闭并希望暂时使用IP地址等，这意味着需要更新Pillar数据并重新启动Proxy Minion进程重启。 在这种情况下，你可以传递force_reconnect = True关键字参数以及备用连接详细信息，以强制执行通过单独连接执行的命令。

例如，如果通常的命令是salt'*'net.arp，则可以使用以下内容来使用不同的用户名进行连接：
```bash
salt '*' net.arp username=my-alt-usr force_reconnect=True
```
与NAPALM连接所需的任何其他配置参数的使用方法类似 - 请参阅[NAPALM代理文档](#https://docs.saltstack.com/en/latest/ref/proxy/all/salt.proxy.napalm.html#module-salt.proxy.napalm)。

### CONFIGURATION REPLACE FEATURES
要替换各种配置块，可以使用新的net.replace_pattern执行函数或netconfig.replace_pattern State函数。 例如，如果要更新配置并重命名在许多位置引用的BGP策略，可以通过运行以下命令来执行此操作：
```bash
salt '*' net.replae_pattern OLD-POLICY-CONFIG new-policy-config
```
同样地，你也可以使用[net.blockreplace](#https://docs.saltstack.com/en/latest/ref/modules/all/salt.modules.napalm_network.html#salt.modules.napalm_network.blockreplace)函数替换整个配置块。

### CONFIGURATION SAVE FEATURES
net.save_config函数可用于将受管设备的配置保存到文件中。 对于State子系统，添加了netconfig.saved函数，该函数在管理可以保存网络设备配置的目标文件时提供完整的工具列表。

例如，在其自己的目录树下备份每个设备的运行配置：
```yaml_utf8
/var/backups/{{ opts.id }}/running.cfg:
  netconfig.saved:
    - source: running
    - makedirs: true
```
上面提到的所有新的网络自动化模块都直接暴露给NAPALM用户，无需任何架构更改，在管理具体网络设备时只需最终按设备系统类型安装一些依赖包：

**1. JUNOS**

现有[junos执行模块](#https://docs.saltstack.com/en/latest/ref/modules/all/salt.modules.junos.html#module-salt.modules.junos)的功能可通过以下函数获得：

- napalm.junos_cli: Execute a CLI command and return the output as text or Python dictionary.
- napalm.junos_rpc: Execute an RPC request on the remote Junos device, and return the result as a Python dictionary, easy to digest and manipulate.
- napalm.junos_install_os: Install the given image on the device.
- napalm.junos_facts: The complete list of Junos facts collected by the junos-eznc underlying library.

>能够使用这些功能，需要确保先满足junos模块的一些依赖性要求。 由于junos-eznc也是NAPALM的依赖项，所以只需要再安装一个jxmlease。详见junos模块说明。

使用样例：
```bash
salt '*' napalm.junos_cli 'show arp' format=xml
salt '*' napalm.junos_rpc get-interface-information
```

**2. NETMIKO**

新添加的[netmiko](#https://docs.saltstack.com/en/latest/ref/modules/all/salt.modules.netmiko_mod.html#module-salt.modules.netmiko_mod)执行模块的功能如下：
- napalm.netmiko_commands: 通过Netmiko执行一个或多个要在远程设备上执行的命令，并将输出作为文本返回。
- napalm.netmiko_config: 通过Netmiko在远程设备上加载一个配置命令的列表。 这些命令既可以从本地，也可以从远程路径加载，通过Salt的模板渲染pipeline传递（默认情况下使用Jinja作为模板渲染引擎）。

使用样例：
```bash
salt '*' napalm.netmiko_commands 'show version' 'show interfaces'
salt '*' napalm.netmiko_config config_file=https://bit.ly/2sgljCB
```

**3. ARISTA PYEAPI**

对于各种操作和各种扩展模块，[pyeapi](#https://docs.saltstack.com/en/latest/ref/modules/all/salt.modules.arista_pyeapi.html#module-salt.modules.arista_pyeapi)模块增加了以下功能：
- napalm.pyeapi_run_commands: Execute a list of commands on the Arista switch, via the pyeapi library.
- napalm.pyeapi_config: Configure the Arista switch with the specified commands, via the pyeapi Python library. Similarly to napalm.netmiko_config, you can use both local and remote files, with or without templating.

使用样例：
```bash
salt '*' napalm.pyeapi_run_commands 'show version' 'show interfaces'
salt '*' napalm.pyeapi_config config_file=salt://path/to/template.jinja
```

**4. CISCO NX-API**

以与上面完全相同的方式，用户可以通过使用以下配置原语通过NX-API管理Cisco Nexus交换机进行完全的控制：
- napalm.nxos_api_show: Execute one or more show (non-configuration) commands, and return the output as plain text or Python dictionary.
- napalm.nxos_api_rpc: Execute arbitrary RPC requests via the Nexus API.
- napalm.nxos_api_config: 使用指定的命令通过NX-API配置Nexus交换机。 可以从命令行或本地或远程文件加载命令，最终使用所选的模板引擎（默认值：jinja）进行渲染。

使用样例：
```bash
salt '*' napalm.nxos_api_show 'show bgp sessions' 'show processes' raw_text=False
```

**5. CISCOCONFPARSE**

在操作Cisco IOS或Junos样式配置时，以下功能列表可能很方便：
- napalm.config_filter_lines: 根据正则表达式匹配得到的其父级和子级节点关系，返回配置块的详细匹配列表。
- napalm.config_find_lines: 返回与提供的正则表达式匹配的配置行。
- napalm.config_lines_w_child: 返回与正则表达式匹配的配置行，且其子行与子正则表达式匹配。
- napalm.config_lines_wo_child: 返回与正则表达式匹配的配置行，且这些配置行没有与子正则表达式匹配的子行。

>这些函数需要安装ciscoconfparse Python库。

使用样例：
```bash
salt '*' napalm.config_lines_w_child 'interface' 'shutdown'
```

**6. IOSCONFIG**

对于Cisco IOS样式配置，在napalm执行模块中添加了以下功能：
- napalm.config_tree: 获取并将Cisco IOS样式配置转换为结构化Python字典。
- napalm.config_merge_tree: 获取受管理设备的配置树，并将其他配置内容合并配置树中（不实际加载设备上的任何更改）。
- napalm.config_merge_text: 获取受管理设备的配置树，并将其他配置内容合并配置树中，将合并后的结果保存为一个文本文件。
- napalm.config_merge_diff: 获取受管理设备的配置树，并将其他配置内容合并配置树中，返回那些有差别的合并内容（不实际加载设备上的任何更改）。

**SCP**

利NAPALM实现的连接与认证，现在还可以使用以下功能：
- napalm.scp_put: 传输文件或文件夹到远程的网络设备上。
- napalm.scp_get: 将文件和目录从远程网络设备传输到Minion的localhost。

### PEERINGDB
[peeringdb](#https://docs.saltstack.com/en/latest/ref/modules/all/salt.modules.peeringdb.html#module-salt.modules.peeringdb)执行模块可用于收集有关可能与你的网络对等的其他网络的信息，并自动建立BGP会话，例如，仅需给定特定的AS号，其余数据（即IP地址，远程网络所在的位置） 从PeeringDB中检索可用的，并且会话配置是自动化的，只需要很少的维护（手动输入IP地址既繁琐又容易出错）。

# NEW DOCKER PROXY MINION
现在可以使用新的docker proxy minion将Docker容器视为实际的minions，而无需在容器中安装salt。

此代理minion使用[docker executor](#https://docs.saltstack.com/en/latest/ref/executors/all/salt.executors.docker.html#module-salt.executors.docker)通过[docker.call](#https://docs.saltstack.com/en/latest/ref/modules/all/salt.modules.dockermod.html#salt.modules.dockermod.call)将命令传递到docker容器。 任何状态模块调用都通过[docker模块](#https://docs.saltstack.com/en/latest/ref/modules/all/salt.modules.dockermod.html#module-salt.modules.dockermod)的相应函数传递。

使用样例：
```bash
proxy:
  proxytype: docker
  name: keen_proskuriakova
```
```bash
salt myminion docker.call test.ping
salt myminion test.arg arg1 arg2 key1=val1
salt myminion dockerng.call compassionate_mirzakhani test.arg arg1 arg2 key1=val1
```

# TERRAFORM SALT-SSH ROSTER
现在可以使用[terraform-provider-salt](#https://github.com/dmacvicar/terraform-provider-salt)定义的terraform资源动态生成Salt-SSH名册。

这允许结合使用terraform和Salt-SSH来监视和配置主机。 有关如何设置和使用的示例，请参阅[terraform](#https://docs.saltstack.com/en/latest/ref/roster/all/salt.roster.terraform.html#module-salt.roster.terraform)列表。

# GRAINS DICTIONARY PASSED INTO CUSTOM GRAINS
从这个版本开始，如果在使用自定义grains函数时接受一个名为grains的变量，那么已经编译过的grains的Grains字典将被传入。由于grains在被渲染时的顺序是不确定的，唯一可以确定且可以被传入的是core.py grains，因为这些是首先编译的。

# MORE PRECISE VIRTUAL GRAIN
在嵌套虚拟化环境（例如VM中的systemd-nspawn容器）中运行Salt并且安装了virt-what时，此版本提高了virtual grain的准确性。

到目前为止，virtual grain是通过匹配virt-what而不是单个项目的所有输出行来确定的，这可能导致不太精确的结果（例如，在基于Hyper-V的VM中运行的systemd-nspawn容器内报告HyperV）。

# CONFIGURABLE MODULE ENVIRONMENT

https://docs.saltstack.com/en/latest/topics/releases/2019.2.0.html#configurable-module-environment
